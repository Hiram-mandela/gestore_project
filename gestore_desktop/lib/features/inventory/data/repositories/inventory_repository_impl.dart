// ========================================
// lib/features/inventory/data/repositories/inventory_repository_impl.dart
// Impl√©mentation du repository inventory
// VERSION COMPL√àTE avec CRUD
// ========================================

import 'package:injectable/injectable.dart';
import 'package:logger/logger.dart';
import '../../domain/entities/article_entity.dart';
import '../../domain/entities/article_detail_entity.dart';
import '../../domain/entities/category_entity.dart';
import '../../domain/entities/brand_entity.dart';
import '../../domain/entities/unit_of_measure_entity.dart';
import '../../domain/entities/paginated_response_entity.dart';
import '../../domain/repositories/inventory_repository.dart';
import '../../domain/usecases/create_article_usecase.dart';
import '../../domain/usecases/update_article_usecase.dart';
import '../datasources/inventory_remote_datasource.dart';

/// Impl√©mentation du repository inventory
/// Fait le pont entre le DataSource et le Domain Layer
@LazySingleton(as: InventoryRepository)
class InventoryRepositoryImpl implements InventoryRepository {
  final InventoryRemoteDataSource remoteDataSource;
  final Logger logger;

  InventoryRepositoryImpl({
    required this.remoteDataSource,
    required this.logger,
  });

  // ==================== ARTICLES - LECTURE ====================

  @override
  Future<(PaginatedResponseEntity<ArticleEntity>?, String?)> getArticles({
    int page = 1,
    int pageSize = 20,
    String? search,
    String? categoryId,
    String? brandId,
    bool? isActive,
    bool? isLowStock,
    String? ordering,
  }) async {
    try {
      logger.d('üì¶ Repository: R√©cup√©ration articles page $page');

      final responseModel = await remoteDataSource.getArticles(
        page: page,
        pageSize: pageSize,
        search: search,
        categoryId: categoryId,
        brandId: brandId,
        isActive: isActive,
        isLowStock: isLowStock,
        ordering: ordering,
      );

      // Convertir le model en entity
      final responseEntity = responseModel.toEntity(
            (articleModel) => articleModel.toEntity(),
      );

      logger.i('‚úÖ Repository: ${responseEntity.count} articles r√©cup√©r√©s');

      return (responseEntity, null);
    } catch (e) {
      final errorMessage = e.toString();
      logger.e('‚ùå Repository: Erreur r√©cup√©ration articles: $errorMessage');
      return (null, _extractErrorMessage(errorMessage));
    }
  }

  @override
  Future<(ArticleEntity?, String?)> getArticleById(String id) async {
    try {
      logger.d('üì¶ Repository: R√©cup√©ration article $id');

      final articleModel = await remoteDataSource.getArticleById(id);
      final articleEntity = articleModel.toEntity();

      logger.i('‚úÖ Repository: Article ${articleEntity.name} r√©cup√©r√©');

      return (articleEntity, null);
    } catch (e) {
      final errorMessage = e.toString();
      logger.e('‚ùå Repository: Erreur r√©cup√©ration article: $errorMessage');
      return (null, _extractErrorMessage(errorMessage));
    }
  }

  @override
  Future<(ArticleDetailEntity?, String?)> getArticleDetailById(String id) async {
    try {
      logger.d('üì¶ Repository: R√©cup√©ration d√©tail article $id');

      final articleDetailModel = await remoteDataSource.getArticleDetailById(id);
      final articleDetailEntity = articleDetailModel.toEntity();

      logger.i('‚úÖ Repository: D√©tail article ${articleDetailEntity.name} r√©cup√©r√©');
      logger.d('   - Cat√©gorie: ${articleDetailEntity.category?.name ?? "N/A"}');
      logger.d('   - Marque: ${articleDetailEntity.brand?.name ?? "N/A"}');
      logger.d('   - Stock: ${articleDetailEntity.currentStock}');
      logger.d('   - Images: ${articleDetailEntity.images.length}');
      logger.d('   - Variantes: ${articleDetailEntity.variants.length}');
      logger.d('   - Historique prix: ${articleDetailEntity.priceHistory.length}');

      return (articleDetailEntity, null);
    } catch (e) {
      final errorMessage = e.toString();
      logger.e('‚ùå Repository: Erreur r√©cup√©ration d√©tail article: $errorMessage');
      return (null, _extractErrorMessage(errorMessage));
    }
  }

  @override
  Future<(PaginatedResponseEntity<ArticleEntity>?, String?)> searchArticles({
    required String query,
    int page = 1,
  }) async {
    try {
      logger.d('üîç Repository: Recherche "$query"');

      final responseModel = await remoteDataSource.searchArticles(
        query: query,
        page: page,
      );

      final responseEntity = responseModel.toEntity(
            (articleModel) => articleModel.toEntity(),
      );

      logger.i('‚úÖ Repository: ${responseEntity.count} r√©sultats trouv√©s');

      return (responseEntity, null);
    } catch (e) {
      final errorMessage = e.toString();
      logger.e('‚ùå Repository: Erreur recherche: $errorMessage');
      return (null, _extractErrorMessage(errorMessage));
    }
  }

  @override
  Future<(List<ArticleEntity>?, String?)> getLowStockArticles() async {
    try {
      logger.d('üì¶ Repository: R√©cup√©ration articles stock bas');

      final articlesModel = await remoteDataSource.getLowStockArticles();
      final articlesEntity =
      articlesModel.map((model) => model.toEntity()).toList();

      logger.i('‚úÖ Repository: ${articlesEntity.length} articles stock bas');

      return (articlesEntity, null);
    } catch (e) {
      final errorMessage = e.toString();
      logger.e('‚ùå Repository: Erreur stock bas: $errorMessage');
      return (null, _extractErrorMessage(errorMessage));
    }
  }

  @override
  Future<(List<ArticleEntity>?, String?)> getExpiringSoonArticles() async {
    try {
      logger.d('üì¶ Repository: R√©cup√©ration articles p√©remption proche');

      final articlesModel = await remoteDataSource.getExpiringSoonArticles();
      final articlesEntity =
      articlesModel.map((model) => model.toEntity()).toList();

      logger.i('‚úÖ Repository: ${articlesEntity.length} articles p√©remption proche');

      return (articlesEntity, null);
    } catch (e) {
      final errorMessage = e.toString();
      logger.e('‚ùå Repository: Erreur p√©remption: $errorMessage');
      return (null, _extractErrorMessage(errorMessage));
    }
  }

  // ==================== ARTICLES - CRUD ====================

  @override
  Future<(ArticleEntity?, String?)> createArticle(
      CreateArticleParams params,
      ) async {
    try {
      logger.d('üì¶ Repository: Cr√©ation article "${params.name}"');
      logger.d('   Code: ${params.code}');
      logger.d('   Cat√©gorie: ${params.categoryId}');
      logger.d('   Prix vente: ${params.sellingPrice} FCFA');

      final data = params.toJson();
      final articleModel = await remoteDataSource.createArticle(
        data,
        params.imagePath,
      );

      final articleEntity = articleModel.toEntity();

      logger.i('‚úÖ Repository: Article "${articleEntity.name}" cr√©√© avec succ√®s');
      logger.d('   ID: ${articleEntity.id}');
      logger.d('   Code: ${articleEntity.code}');

      return (articleEntity, null);
    } catch (e) {
      final errorMessage = e.toString();
      logger.e('‚ùå Repository: Erreur cr√©ation article: $errorMessage');
      return (null, _extractErrorMessage(errorMessage));
    }
  }

  @override
  Future<(ArticleEntity?, String?)> updateArticle(
      UpdateArticleParams params,
      ) async {
    try {
      logger.d('üì¶ Repository: Mise √† jour article "${params.name}" (ID: ${params.id})');
      logger.d('   Code: ${params.code}');
      logger.d('   Prix vente: ${params.sellingPrice} FCFA');

      final data = params.toJson();
      final articleModel = await remoteDataSource.updateArticle(
        params.id,
        data,
        params.imagePath,
      );

      final articleEntity = articleModel.toEntity();

      logger.i('‚úÖ Repository: Article "${articleEntity.name}" mis √† jour');

      return (articleEntity, null);
    } catch (e) {
      final errorMessage = e.toString();
      logger.e('‚ùå Repository: Erreur mise √† jour article: $errorMessage');
      return (null, _extractErrorMessage(errorMessage));
    }
  }

  @override
  Future<(void, String?)> deleteArticle(String articleId) async {
    try {
      logger.d('üì¶ Repository: Suppression article (ID: $articleId)');

      await remoteDataSource.deleteArticle(articleId);

      logger.i('‚úÖ Repository: Article supprim√© avec succ√®s');

      return (null, null);
    } catch (e) {
      final errorMessage = e.toString();
      logger.e('‚ùå Repository: Erreur suppression article: $errorMessage');
      return (null, _extractErrorMessage(errorMessage));
    }
  }

  // ==================== CATEGORIES ====================

  @override
  Future<(List<CategoryEntity>?, String?)> getCategories({
    bool? isActive,
  }) async {
    try {
      logger.d('üì¶ Repository: R√©cup√©ration cat√©gories');

      final categoriesModel = await remoteDataSource.getCategories(
        isActive: isActive,
      );

      final categoriesEntity =
      categoriesModel.map((model) => model.toEntity()).toList();

      logger.i('‚úÖ Repository: ${categoriesEntity.length} cat√©gories r√©cup√©r√©es');

      return (categoriesEntity, null);
    } catch (e) {
      final errorMessage = e.toString();
      logger.e('‚ùå Repository: Erreur cat√©gories: $errorMessage');
      return (null, _extractErrorMessage(errorMessage));
    }
  }

  @override
  Future<(CategoryEntity?, String?)> getCategoryById(String id) async {
    try {
      logger.d('üì¶ Repository: R√©cup√©ration cat√©gorie $id');

      final categoryModel = await remoteDataSource.getCategoryById(id);
      final categoryEntity = categoryModel.toEntity();

      logger.i('‚úÖ Repository: Cat√©gorie ${categoryEntity.name} r√©cup√©r√©e');

      return (categoryEntity, null);
    } catch (e) {
      final errorMessage = e.toString();
      logger.e('‚ùå Repository: Erreur cat√©gorie: $errorMessage');
      return (null, _extractErrorMessage(errorMessage));
    }
  }

  @override
  Future<(CategoryEntity?, String?)> createCategory(Map<String, dynamic> data) async {
    try {
      logger.d('üì¶ Repository: Cr√©ation cat√©gorie "${data['name']}"');

      final categoryModel = await remoteDataSource.createCategory(data);
      final categoryEntity = categoryModel.toEntity();

      logger.i('‚úÖ Repository: Cat√©gorie "${categoryEntity.name}" cr√©√©e');

      return (categoryEntity, null);
    } catch (e) {
      final errorMessage = e.toString();
      logger.e('‚ùå Repository: Erreur cr√©ation cat√©gorie: $errorMessage');
      return (null, _extractErrorMessage(errorMessage));
    }
  }

  @override
  Future<(CategoryEntity?, String?)> updateCategory(String id, Map<String, dynamic> data) async {
    try {
      logger.d('üì¶ Repository: Mise √† jour cat√©gorie $id');

      final categoryModel = await remoteDataSource.updateCategory(id, data);
      final categoryEntity = categoryModel.toEntity();

      logger.i('‚úÖ Repository: Cat√©gorie "${categoryEntity.name}" mise √† jour');

      return (categoryEntity, null);
    } catch (e) {
      final errorMessage = e.toString();
      logger.e('‚ùå Repository: Erreur mise √† jour cat√©gorie: $errorMessage');
      return (null, _extractErrorMessage(errorMessage));
    }
  }

  @override
  Future<(void, String?)> deleteCategory(String id) async {
    try {
      logger.d('üì¶ Repository: Suppression cat√©gorie $id');

      await remoteDataSource.deleteCategory(id);

      logger.i('‚úÖ Repository: Cat√©gorie supprim√©e');

      return (null, null);
    } catch (e) {
      final errorMessage = e.toString();
      logger.e('‚ùå Repository: Erreur suppression cat√©gorie: $errorMessage');
      return (null, _extractErrorMessage(errorMessage));
    }
  }

  // ==================== BRANDS ====================

  @override
  Future<(List<BrandEntity>?, String?)> getBrands({
    bool? isActive,
  }) async {
    try {
      logger.d('üì¶ Repository: R√©cup√©ration marques');

      final brandsModel = await remoteDataSource.getBrands(
        isActive: isActive,
      );

      final brandsEntity =
      brandsModel.map((model) => model.toEntity()).toList();

      logger.i('‚úÖ Repository: ${brandsEntity.length} marques r√©cup√©r√©es');

      return (brandsEntity, null);
    } catch (e) {
      final errorMessage = e.toString();
      logger.e('‚ùå Repository: Erreur marques: $errorMessage');
      return (null, _extractErrorMessage(errorMessage));
    }
  }

  @override
  Future<(BrandEntity?, String?)> getBrandById(String id) async {
    try {
      logger.d('üì¶ Repository: R√©cup√©ration marque $id');

      final brandModel = await remoteDataSource.getBrandById(id);
      final brandEntity = brandModel.toEntity();

      logger.i('‚úÖ Repository: Marque ${brandEntity.name} r√©cup√©r√©e');

      return (brandEntity, null);
    } catch (e) {
      final errorMessage = e.toString();
      logger.e('‚ùå Repository: Erreur marque: $errorMessage');
      return (null, _extractErrorMessage(errorMessage));
    }
  }

  @override
  Future<(BrandEntity?, String?)> createBrand(Map<String, dynamic> data, String? logoPath) async {
    try {
      logger.d('üì¶ Repository: Cr√©ation marque "${data['name']}"');

      final brandModel = await remoteDataSource.createBrand(data, logoPath);
      final brandEntity = brandModel.toEntity();

      logger.i('‚úÖ Repository: Marque "${brandEntity.name}" cr√©√©e');

      return (brandEntity, null);
    } catch (e) {
      final errorMessage = e.toString();
      logger.e('‚ùå Repository: Erreur cr√©ation marque: $errorMessage');
      return (null, _extractErrorMessage(errorMessage));
    }
  }

  @override
  Future<(BrandEntity?, String?)> updateBrand(String id, Map<String, dynamic> data, String? logoPath) async {
    try {
      logger.d('üì¶ Repository: Mise √† jour marque $id');

      final brandModel = await remoteDataSource.updateBrand(id, data, logoPath);
      final brandEntity = brandModel.toEntity();

      logger.i('‚úÖ Repository: Marque "${brandEntity.name}" mise √† jour');

      return (brandEntity, null);
    } catch (e) {
      final errorMessage = e.toString();
      logger.e('‚ùå Repository: Erreur mise √† jour marque: $errorMessage');
      return (null, _extractErrorMessage(errorMessage));
    }
  }

  @override
  Future<(void, String?)> deleteBrand(String id) async {
    try {
      logger.d('üì¶ Repository: Suppression marque $id');

      await remoteDataSource.deleteBrand(id);

      logger.i('‚úÖ Repository: Marque supprim√©e');

      return (null, null);
    } catch (e) {
      final errorMessage = e.toString();
      logger.e('‚ùå Repository: Erreur suppression marque: $errorMessage');
      return (null, _extractErrorMessage(errorMessage));
    }
  }

  // ==================== UNITS OF MEASURE ====================

  @override
  Future<(List<UnitOfMeasureEntity>?, String?)> getUnitsOfMeasure({
    bool? isActive,
  }) async {
    try {
      logger.d('üì¶ Repository: R√©cup√©ration unit√©s de mesure');

      final unitsModel = await remoteDataSource.getUnitsOfMeasure(
        isActive: isActive,
      );

      final unitsEntity =
      unitsModel.map((model) => model.toEntity()).toList();

      logger.i('‚úÖ Repository: ${unitsEntity.length} unit√©s r√©cup√©r√©es');

      return (unitsEntity, null);
    } catch (e) {
      final errorMessage = e.toString();
      logger.e('‚ùå Repository: Erreur unit√©s: $errorMessage');
      return (null, _extractErrorMessage(errorMessage));
    }
  }

  @override
  Future<(UnitOfMeasureEntity?, String?)> getUnitById(String id) async {
    try {
      logger.d('üì¶ Repository: R√©cup√©ration unit√© $id');

      final unitModel = await remoteDataSource.getUnitById(id);
      final unitEntity = unitModel.toEntity();

      logger.i('‚úÖ Repository: Unit√© ${unitEntity.name} r√©cup√©r√©e');

      return (unitEntity, null);
    } catch (e) {
      final errorMessage = e.toString();
      logger.e('‚ùå Repository: Erreur r√©cup√©ration unit√©: $errorMessage');
      return (null, _extractErrorMessage(errorMessage));
    }
  }

  @override
  Future<(UnitOfMeasureEntity?, String?)> createUnit(Map<String, dynamic> data) async {
    try {
      logger.d('üì¶ Repository: Cr√©ation unit√© "${data['name']}"');

      final unitModel = await remoteDataSource.createUnit(data);
      final unitEntity = unitModel.toEntity();

      logger.i('‚úÖ Repository: Unit√© "${unitEntity.name}" cr√©√©e');

      return (unitEntity, null);
    } catch (e) {
      final errorMessage = e.toString();
      logger.e('‚ùå Repository: Erreur cr√©ation unit√©: $errorMessage');
      return (null, _extractErrorMessage(errorMessage));
    }
  }

  @override
  Future<(UnitOfMeasureEntity?, String?)> updateUnit(String id, Map<String, dynamic> data) async {
    try {
      logger.d('üì¶ Repository: Mise √† jour unit√© $id');

      final unitModel = await remoteDataSource.updateUnit(id, data);
      final unitEntity = unitModel.toEntity();

      logger.i('‚úÖ Repository: Unit√© "${unitEntity.name}" mise √† jour');

      return (unitEntity, null);
    } catch (e) {
      final errorMessage = e.toString();
      logger.e('‚ùå Repository: Erreur mise √† jour unit√©: $errorMessage');
      return (null, _extractErrorMessage(errorMessage));
    }
  }

  @override
  Future<(void, String?)> deleteUnit(String id) async {
    try {
      logger.d('üì¶ Repository: Suppression unit√© $id');

      await remoteDataSource.deleteUnit(id);

      logger.i('‚úÖ Repository: Unit√© supprim√©e');

      return (null, null);
    } catch (e) {
      final errorMessage = e.toString();
      logger.e('‚ùå Repository: Erreur suppression unit√©: $errorMessage');
      return (null, _extractErrorMessage(errorMessage));
    }
  }

  // ==================== UTILITAIRES ====================

  /// Extrait un message d'erreur lisible pour l'utilisateur
  String _extractErrorMessage(String error) {
    // Nettoyer le message d'erreur
    if (error.contains('Exception:')) {
      return error.split('Exception:').last.trim();
    }
    if (error.contains('Error:')) {
      return error.split('Error:').last.trim();
    }
    return error;
  }
}